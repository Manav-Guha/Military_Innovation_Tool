<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Military Innovation Assessment Framework</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @media print { .no-print { display: none; } }
        .score-badge { border-radius: 9999px; padding: 0.25rem 0.75rem; font-weight: 700; font-size: 0.85rem; }
        .slider-thumb::-webkit-slider-thumb {
          -webkit-appearance: none;
          width: 16px;
          height: 16px;
          border-radius: 50%;
          background: #4a5568;
          cursor: pointer;
        }
        .slider-thumb::-moz-range-thumb {
          width: 16px;
          height: 16px;
          border-radius: 50%;
          background: #4a5568;
          cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const DIMENSIONS = {
            discontinuity: {
                name: "Discontinuity",
                description: "Breaks existing patterns rather than extending them",
                indicators: [
                    { id: "d1", label: "Enemy OODA disruption" },
                    { id: "d2", label: "Doctrinal break points" },
                    { id: "d3", label: "Kill-chain topology shift" },
                    { id: "d4", label: "Adversary scrambling to counter" }
                ]
            },
            irreversibility: {
                name: "Irreversibility",
                description: "Creates path dependence, making reversal difficult",
                indicators: [
                    { id: "i1", label: "Training/institutional restructuring" },
                    { id: "i2", label: "Logistics/infrastructure path dependence" },
                    { id: "i3", label: "Adversary compulsion to mirror at scale" },
                    { id: "i4", label: "Persistent force structure changes" }
                ]
            },
            generative: {
                name: "Generative",
                description: "Enables new systems and doctrines",
                indicators: [
                    { id: "g1", label: "Follow-on doctrines/capabilities (5â€“10y)" },
                    { id: "g2", label: "Cross-domain spillovers" },
                    { id: "g3", label: "Budget share migration" },
                    { id: "g4", label: "New capability categories emerge" }
                ]
            },
            cognitive: {
                name: "Cognitive",
                description: "Shifts mental models and beliefs",
                indicators: [
                    { id: "c1", label: "Doctrinal rewrites" },
                    { id: "c2", label: "PME syllabus changes" },
                    { id: "c3", label: "Wargame outcome reversals" },
                    { id: "c4", label: "Leadership reframes success metrics" }
                ]
            }
        };

        const DIM_KEYS = Object.keys(DIMENSIONS);

        const ALL_INDICATORS = DIM_KEYS.flatMap(dimKey => DIMENSIONS[dimKey].indicators.map(ind => ({ ...ind, dim: dimKey })));

        const EXAMPLES = {
          "AI-Targeting": {
              conservativeScores: { d1:1, d2:1, d3:1, d4:1, i1:1, i2:1, i3:1, i4:1, g1:2, g2:2, g3:2, g4:2, c1:1, c2:1, c3:1, c4:1 },
              justification: "Automated targeting enhances kill chains but doesn't fundamentally rewrite them yet. It creates new capabilities but isn't forcing a complete institutional overhaul.",
              sources: ["USAF Mad Scientist Initial Research"],
              causalChain: [
                { source: "g3", target: "i3", bump: 1, explanation: "A shift in budget toward AI creates pressure for adversaries to acquire a similar capability (Irreversibility)." },
                { source: "d1", target: "c3", bump: 1, explanation: "AI's ability to shorten the targeting cycle (Discontinuity) directly leads to new outcomes in wargames (Cognitive)." },
              ]
          },
          "Blitzkrieg": {
              conservativeScores: { d1:2, d2:2, d3:2, d4:2, i1:2, i2:2, i3:2, i4:2, g1:2, g2:2, g3:2, g4:2, c1:2, c2:2, c3:2, c4:2 },
              justification: "Blitzkrieg was a total system innovation, combining tanks, close air support, and radio communication into a new way of war. It forced adversaries to rethink everything, leading to deep doctrinal and institutional changes.",
              sources: ["Liddell Hart on Blitzkrieg", "Guderian's Panzer Leader"],
              causalChain: [
                { source: "d2", target: "c1", bump: 1, explanation: "High score in 'Doctrinal break points' (Discontinuity) caused 'Doctrinal rewrites' (Cognitive)." },
                { source: "g1", target: "i4", bump: 1, explanation: "Follow-on doctrines enabled by Blitzkrieg led to permanent force structure changes." }
              ]
          },
          "Nuclear Weapons": {
              conservativeScores: { d1:3, d2:3, d3:3, d4:3, i1:3, i2:3, i3:3, i4:3, g1:3, g2:3, g3:3, g4:3, c1:3, c2:3, c3:3, c4:3 },
              justification: "The ultimate military innovation. It created a total discontinuity, made previous models of total war obsolete, was completely generative of new doctrines (MAD), was irreversible, and forced a complete cognitive shift in military and political thinking.",
              sources: ["The Making of the Atomic Bomb by Richard Rhodes", "On Thermonuclear War by Herman Kahn"],
              causalChain: [
                { source: "d3", target: "c4", bump: 1, explanation: "The new kill-chain topology (a Discontinuity effect) forced leadership to adopt new metrics for success (Cognitive)." },
                { source: "g4", target: "i1", bump: 1, explanation: "The emergence of new capability categories led to a massive and irreversible restructuring of military training and institutions." }
              ]
          },
        };

        const RUBRICS = {
          0: "No evidence",
          1: "Prototype/lab only",
          2: "Field trials/limited ops",
          3: "Adversary response or institutional change",
          4: "Doctrinal/strategic transformation"
        };

        const classify = (scores) => {
            const d = DIMENSIONS.discontinuity.indicators.reduce((sum, ind) => sum + (scores[ind.id] || 0), 0);
            const i = DIMENSIONS.irreversibility.indicators.reduce((sum, ind) => sum + (scores[ind.id] || 0), 0);
            const g = DIMENSIONS.generative.indicators.reduce((sum, ind) => sum + (scores[ind.id] || 0), 0);
            const c = DIMENSIONS.cognitive.indicators.reduce((sum, ind) => sum + (scores[ind.id] || 0), 0);
            const total = d + i + g + c;

            if (total === 0) return { bucket: "None of the Above", total, d, i, g, c, classificationText: "No innovation has been scored. Please use the sliders to begin your assessment." };
            if (total >= 15 && (i >= 9 || c >= 9)) return { bucket: "Genuine Innovation", total, d, i, g, c, classificationText: "This qualifies as a 'Genuine Innovation.' Genuine Innovations are rare and difficult to achieve. They fundamentally redefine military power, requiring deep doctrinal and institutional changes that are often irreversible. The high scores in Irreversibility and/or Cognitive Disruption signal a transformative, rather than merely technical, effect." };
            if (d >= 1 && i === 0 && g === 0 && c === 0) return { bucket: "Adaptation", total, d, i, g, c, classificationText: "This is an 'Adaptation.' It is a reactive change to a new threat or circumstance. It is characterized by a high Discontinuity score but low scores in the other dimensions, indicating that it does not fundamentally change the system. Think of it as a tactical or operational tweak rather than a strategic transformation."};
            if (total >= 10 && d > 0 && i >= 1) return { bucket: "Modernization", total, d, i, g, c, classificationText: "This qualifies as 'Modernization.' Modernization improves upon existing systems and doctrines, making them more efficient and effective. It often involves upgrades that are irreversible and can create new capabilities, but it does not fundamentally change the nature of war. The scores indicate a significant, but not revolutionary, change." };
            return { bucket: "Upgradation", total, d, i, g, c, classificationText: "This is an 'Upgradation.' It is a simple improvement to an existing system, such as a new sensor or a software update. It has a low total score and does not significantly change any of the four dimensions. It is an example of an evolutionary, not revolutionary, change." };
        };

        const makeDefaultScores = () => {
          const s = {};
          DIM_KEYS.forEach(dim => DIMENSIONS[dim].indicators.forEach(ind => s[ind.id] = 0));
          return s;
        };
        
        // This function applies the causal chains to the base scores
        const applyCausalChains = (baseScores, chains) => {
          const integratedScores = { ...baseScores };
          chains.forEach(chain => {
            const { source, target, bump } = chain;
            if (integratedScores[source] > 0) {
                const currentScore = integratedScores[target] || 0;
                integratedScores[target] = Math.min(4, currentScore + bump);
            }
          });
          return integratedScores;
        };


        const App = () => {
            const [label, setLabel] = useState("");
            const [scores, setScores] = useState(makeDefaultScores());
            const [showRubrics, setShowRubrics] = useState(false);
            const [selectedExample, setSelectedExample] = useState(null);
            const [userCausalChains, setUserCausalChains] = useState([]);
            const [newChain, setNewChain] = useState({ source: "", target: "", bump: 1 });

            const dimensionChartRef = useRef(null);
            const indicatorChartRef = useRef(null);

            const allCausalChains = useMemo(() => {
                const exampleChains = selectedExample ? EXAMPLES[selectedExample].causalChain : [];
                return [...exampleChains, ...userCausalChains];
            }, [selectedExample, userCausalChains]);

            const integratedScores = useMemo(() => applyCausalChains(scores, allCausalChains), [scores, allCausalChains]);

            const conservativeClassification = useMemo(() => classify(scores), [scores]);
            const integratedClassification = useMemo(() => classify(integratedScores), [integratedScores]);

            const calculateDimensionScores = (currentScores) => {
              return DIM_KEYS.reduce((acc, key) => ({
                ...acc,
                [key]: DIMENSIONS[key].indicators.reduce((sum, ind) => sum + (currentScores[ind.id] || 0), 0)
              }), {});
            };

            const conservativeDimensionScores = useMemo(() => calculateDimensionScores(scores), [scores]);
            const integratedDimensionScores = useMemo(() => calculateDimensionScores(integratedScores), [integratedScores]);

            const updateCharts = () => {
                if (dimensionChartRef.current) {
                    dimensionChartRef.current.data.datasets[0].data = Object.values(conservativeDimensionScores);
                    dimensionChartRef.current.data.datasets[1].data = Object.values(integratedDimensionScores);
                    dimensionChartRef.current.update();
                }

                if (indicatorChartRef.current) {
                    indicatorChartRef.current.data.datasets[0].data = Object.values(scores);
                    indicatorChartRef.current.data.datasets[1].data = Object.values(integratedScores);
                    indicatorChartRef.current.update();
                }
            };

            useEffect(() => {
                const dimensionChartCtx = document.getElementById('dimension-chart').getContext('2d');
                if (dimensionChartRef.current) { dimensionChartRef.current.destroy(); }
                dimensionChartRef.current = new Chart(dimensionChartCtx, {
                    type: 'bar',
                    data: {
                        labels: DIM_KEYS.map(key => DIMENSIONS[key].name),
                        datasets: [
                            { label: 'Conservative', data: Object.values(conservativeDimensionScores), backgroundColor: ['#FCA5A5', '#FDBA74', '#FCD34D', '#FDE047'], borderColor: ['#EF4444', '#F97316', '#F59E0B', '#FACC15'], borderWidth: 1 },
                            { label: 'Integrated', data: Object.values(integratedDimensionScores), backgroundColor: 'rgba(52, 211, 153, 0.6)', borderColor: '#10B981', borderWidth: 1 }
                        ]
                    },
                    options: { responsive: true, scales: { y: { beginAtZero: true, max: 16 } } }
                });
                
                const indicatorChartCtx = document.getElementById('indicator-chart').getContext('2d');
                if (indicatorChartRef.current) { indicatorChartRef.current.destroy(); }
                indicatorChartRef.current = new Chart(indicatorChartCtx, {
                    type: 'bar',
                    data: {
                        labels: ALL_INDICATORS.map(i => i.label),
                        datasets: [
                            { label: 'Conservative', data: Object.values(scores), backgroundColor: 'rgba(251, 191, 36, 0.6)', borderColor: '#F59E0B', borderWidth: 1 },
                            { label: 'Integrated', data: Object.values(integratedScores), backgroundColor: 'rgba(52, 211, 153, 0.6)', borderColor: '#10B981', borderWidth: 1 }
                        ]
                    },
                    options: { responsive: true, indexAxis: 'y', scales: { x: { beginAtZero: true, max: 4 } } }
                });

            }, [scores, integratedScores]);
            
            useEffect(() => { updateCharts(); }, [scores, integratedScores]);


            const setIndicator = (id, value) => {
                setScores(prevScores => ({ ...prevScores, [id]: value }));
                setSelectedExample(null);
                setUserCausalChains([]);
            };

            const resetAll = () => {
                setLabel("");
                setScores(makeDefaultScores());
                setSelectedExample(null);
                setUserCausalChains([]);
            };

            const loadExample = (name) => {
                setLabel(name);
                setScores(EXAMPLES[name].conservativeScores);
                setSelectedExample(name);
                setUserCausalChains([]);
            };

            const handleAddChain = (e) => {
                e.preventDefault();
                if (newChain.source && newChain.target) {
                    const sourceDim = ALL_INDICATORS.find(ind => ind.id === newChain.source).dim;
                    const targetDim = ALL_INDICATORS.find(ind => ind.id === newChain.target).dim;
                    const explanation = `User-defined link from ${DIMENSIONS[sourceDim].name} to ${DIMENSIONS[targetDim].name}`;
                    setUserCausalChains(prev => [...prev, { ...newChain, explanation }]);
                    setNewChain({ source: "", target: "", bump: 1 });
                }
            };
            
            const CausalChainDisplay = ({ chains }) => {
                if (chains.length === 0) {
                    return <p className="text-sm text-gray-600">No causal chains defined for this innovation.</p>;
                }
                return (
                    <ul className="list-disc list-inside space-y-2">
                        {chains.map((chain, index) => (
                            <li key={index} className="text-sm text-gray-700">
                                <span className="font-semibold">{ALL_INDICATORS.find(ind => ind.id === chain.source).label}</span>
                                <span className="text-xs text-gray-500 ml-1">(+{chain.bump})</span>
                                <span className="mx-2 font-bold">â†’</span>
                                <span className="font-semibold">{ALL_INDICATORS.find(ind => ind.id === chain.target).label}</span>
                                {chain.explanation && <p className="text-xs text-gray-500 mt-1">{chain.explanation}</p>}
                            </li>
                        ))}
                    </ul>
                );
            };


            return (
                <div className="max-w-7xl mx-auto p-6 space-y-8">
                    <header className="text-center space-y-1">
                        <h1 className="text-4xl md:text-5xl font-extrabold text-gray-900">
                            Military Innovation Assessment Framework
                        </h1>
                        <p className="text-lg text-gray-700">A Four-Dimensional Recognition Tool</p>
                        <p className="italic text-sm text-gray-600">
                            Based on "The Innovation Delusion: How Conceptual Confusion Undermines Military Strategy"
                        </p>
                    </header>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="md:col-span-2 p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Case Setup</h2>
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Case Label</label>
                                    <input
                                        type="text"
                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                                        placeholder="e.g., Fiber optics (dual-use substrate)"
                                        value={label}
                                        onChange={(e) => setLabel(e.target.value)}
                                    />
                                </div>
                                <div className="flex items-center gap-2">
                                    <input
                                        type="checkbox"
                                        checked={showRubrics}
                                        onChange={(e) => setShowRubrics(e.target.checked)}
                                        className="h-4 w-4 text-indigo-600 border-gray-300 rounded"
                                    />
                                    <span className="text-sm text-gray-700">Show scoring rubric tooltips</span>
                                </div>
                                <button
                                    onClick={resetAll}
                                    className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 no-print"
                                >
                                    Reset All
                                </button>
                            </div>
                        </div>

                        <div className="p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Classification</h2>
                            <div className="mb-4">
                                <h3 className="text-lg font-medium text-gray-900">Conservative</h3>
                                <p className="text-sm text-gray-500">Based on your direct input.</p>
                                <div className="mt-2">
                                    <span className={`score-badge ${conservativeClassification.bucket === "Genuine Innovation" ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-800'}`}>
                                        {conservativeClassification.bucket}
                                    </span>
                                </div>
                                <p className="mt-2 text-sm text-gray-600">{conservativeClassification.classificationText}</p>
                            </div>
                            <div>
                                <h3 className="text-lg font-medium text-gray-900">Integrated</h3>
                                <p className="text-sm text-gray-500">With interconnected effects.</p>
                                <div className="mt-2">
                                    <span className={`score-badge ${integratedClassification.bucket === "Genuine Innovation" ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-800'}`}>
                                        {integratedClassification.bucket}
                                    </span>
                                </div>
                                <p className="mt-2 text-sm text-gray-600">
                                  {integratedClassification.classificationText}
                                </p>
                            </div>
                        </div>
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div className="p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Dimension Scores</h2>
                            <div className="h-64">
                                <canvas id="dimension-chart"></canvas>
                            </div>
                        </div>
                        <div className="p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Indicator Scores</h2>
                            <div className="h-64">
                                <canvas id="indicator-chart"></canvas>
                            </div>
                        </div>
                    </div>

                    <div className="p-6 bg-white rounded-lg shadow">
                        <h2 className="text-xl font-semibold mb-4">Scoring</h2>
                        <p className="text-sm text-gray-600 mb-4">Use the sliders to score the innovation across each indicator from 0-4.</p>
                        {DIM_KEYS.map(dimKey => (
                            <div key={dimKey} className="mb-6 p-4 border rounded-lg bg-gray-50">
                                <h3 className="text-lg font-medium text-gray-800 flex items-center mb-2">
                                    {DIMENSIONS[dimKey].name}
                                    <span className="ml-2 text-sm text-gray-500 font-normal">({DIMENSIONS[dimKey].description})</span>
                                </h3>
                                <ul className="space-y-4">
                                    {DIMENSIONS[dimKey].indicators.map(indicator => (
                                        <li key={indicator.id}>
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm font-medium text-gray-700" title={showRubrics ? RUBRICS[scores[indicator.id]] : ""}>
                                                    {indicator.label}
                                                </span>
                                                <span className="ml-2 text-sm font-bold text-gray-900">
                                                  {scores[indicator.id] || 0}
                                                  {integratedScores[indicator.id] > (scores[indicator.id] || 0) && (
                                                    <span className="text-green-500 ml-1">
                                                      (+{integratedScores[indicator.id] - (scores[indicator.id] || 0)})
                                                    </span>
                                                  )}
                                                </span>
                                            </div>
                                            <input
                                                type="range"
                                                min="0"
                                                max="4"
                                                value={scores[indicator.id] || 0}
                                                onChange={(e) => setIndicator(indicator.id, parseInt(e.target.value))}
                                                className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1"
                                                style={{ WebkitAppearance: 'none' }}
                                            />
                                            {showRubrics && (
                                                <div className="text-xs text-gray-500 mt-1">
                                                    {RUBRICS[scores[indicator.id] || 0]}
                                                </div>
                                            )}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        ))}
                    </div>
                    
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div className="p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Historical Examples</h2>
                            <p className="text-sm text-gray-600 mb-4">Click an example to load its pre-configured scores and analysis.</p>
                            <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2">
                                {Object.keys(EXAMPLES).map(name => (
                                    <button
                                        key={name}
                                        onClick={() => loadExample(name)}
                                        className={`py-2 px-4 rounded-md text-sm font-medium text-gray-700 border transition-colors ${selectedExample === name ? 'bg-indigo-100 border-indigo-500' : 'bg-gray-100 hover:bg-gray-200'}`}
                                    >
                                        {name}
                                    </button>
                                ))}
                            </div>
                        </div>
                        
                        <div className="p-6 bg-white rounded-lg shadow">
                            <h2 className="text-xl font-semibold mb-4">Detailed Analysis</h2>
                            {selectedExample ? (
                                <div>
                                    <h3 className="text-lg font-semibold mb-2">{selectedExample} Justification</h3>
                                    <p className="mb-4 text-sm text-gray-700">{EXAMPLES[selectedExample].justification}</p>
                                    <h3 className="text-lg font-semibold mb-2">Indicative Sources</h3>
                                    <ul className="list-disc list-inside space-y-1 text-sm text-gray-700">
                                        {EXAMPLES[selectedExample].sources.map((source, index) => (
                                            <li key={index}>{source}</li>
                                        ))}
                                    </ul>
                                </div>
                            ) : (
                                <p className="text-sm text-gray-600">Select a historical example above to see its detailed justification and indicative sources.</p>
                            )}
                        </div>
                    </div>
                    
                    <div className="p-6 bg-white rounded-lg shadow">
                        <h2 className="text-xl font-semibold mb-4">The Principle of Interconnected Effects</h2>
                        <p className="text-sm text-gray-600 mb-4">
                            Define your own causal chains to apply the principle that a score in one dimension can justify a score in another.
                        </p>
                        <div className="space-y-4">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Source Indicator</label>
                                    <select
                                        value={newChain.source}
                                        onChange={(e) => setNewChain(prev => ({ ...prev, source: e.target.value }))}
                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                    >
                                        <option value="">Select...</option>
                                        {ALL_INDICATORS.map(ind => (
                                            <option key={ind.id} value={ind.id}>
                                                {DIMENSIONS[ind.dim].name}: {ind.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Target Indicator</label>
                                    <select
                                        value={newChain.target}
                                        onChange={(e) => setNewChain(prev => ({ ...prev, target: e.target.value }))}
                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                    >
                                        <option value="">Select...</option>
                                        {ALL_INDICATORS.map(ind => (
                                            <option key={ind.id} value={ind.id}>
                                                {DIMENSIONS[ind.dim].name}: {ind.label}
                                            </option>
                                        ))}
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Score Bump</label>
                                    <input
                                        type="number"
                                        min="1"
                                        max="4"
                                        value={newChain.bump}
                                        onChange={(e) => setNewChain(prev => ({ ...prev, bump: parseInt(e.target.value) }))}
                                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm"
                                    />
                                </div>
                            </div>
                            <button
                                onClick={handleAddChain}
                                className="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500"
                            >
                                Add Causal Link
                            </button>
                        </div>
                        <div className="mt-6">
                            <h3 className="text-lg font-semibold mb-2">Active Causal Chains</h3>
                            <CausalChainDisplay chains={allCausalChains} />
                        </div>
                    </div>

                    <footer className="text-center text-xs text-gray-500 mt-8">
                        Recognition heuristic. It does not define innovation; it evaluates observed effects across four dimensions.
                    </footer>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
